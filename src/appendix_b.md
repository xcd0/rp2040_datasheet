# Appendix B: Errata


Hardware blocks are listed alphabetically. Errata are listed numerically under the relevant block.

## Bootrom

### RP2040-E9

   |   
----------|----------
Reference | RP2040-E9
Summary | ROM bootloader cannot boot directly into XIP cache-as-SRAM
Description | The XIP cache can be used as an additional 16kB SRAM bank when XIP caching is disabled (Section 2.6.3.1). The UF2 bootloader supports RAM-only UF2 binaries, which it loads directly into memory, and enters via a watchdog reboot. A single UF2 binary can initialise both the XIP cache contents and main system memory, and the cache is disabled by the bootloader, so that cache contents be written. <br> <br> However, the watchdog reset re-enables the cache, so booting directly into the cache-as-SRAM alias causes an immediate bus fault. The cache contents are preserved, but can not be accessed immediately post-boot.
Workaround | Add code in main SRAM to re-disable XIP caching before accessing the cache-as-SRAM alias. When entering a RAM-only UF2 binary, the bootloader selects the lowest loaded address in either main SRAM or cache-as-SRAM as the entry point, preferring main SRAM if both are loaded. <br> <br> Additionally, if the 0x15... segment is written immediately post-boot, a dummy read of the FLUSH register is required, so that no cache-as-SRAM writes take place during the tag memory flush triggered by the watchdog (see Section 2.6.3.2).
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Documentation

### RP2040-E14

   |   
----------|----------
Reference | RP2040-E14
Summary | Sparse or mis-aligned flash-binary UF2 may not be written to flash correctly by the UF2 bootloader
Description | A RP2040 UF2 file consists of 256-byte pages of data, each marked to be written at a certain address by the UF2 bootloader. A flash-binary UF2 is one of these for which every 256-byte page is marked to be written at a 256-byte-aligned address in flash. <br> <br> When writing flash, an entire 4kB flash sector must be erased at a time before any pages within that sector can be (re-)written. The UF2 bootloader does not require the flash-binary UF2 to include data for all pages within a sector. In that case the whole sector will first be erased, any present pages will be written, and the rest of the 4kB sector will be left undefined. <br> <br> This mechanism works as expected when the partially-filled sector is at the end of the binary, which is of course commonplace, as a binary does not need to be a multiple of 4kB long. <br> <br> If however, the partially-filled sector occurs at the start of the binary (i.e. the binary is not aligned on a 4kB page) or if a partially-filled sector appears in the middle of the binary (i.e. the binary is sparse/non- contiguous), then the UF2 file may be written incorrectly. <br> <br> Note that the vast majority of UF2s generated by the SDK are indeed aligned on a 4kB boundary and contiguous, however it is possible for the SDK to produce a misaligned or non-contiguous binary by modifying the linker scripts, or putting extreme alignment requirements on static data. It is also possible that other languages or tools might produce binaries that are not 4kB-aligned or contiguous.
Workaround | The workaround is to include data for all the pages in any 4kB sector (other than the last) that contains data for some pages. <br> <br> This is handled for you automatically by the elf2uf2 tool in the SDK version 1.3.1 onwards, which explicitly adds zero-filled pages to the appropriate partially-filled sectors.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Documentation / Software

## Clocks

### RP2040-E7

   |   
----------|----------
Reference | RP2040-E7
Summary | ROSC and XOSC COUNT registers are unreliable
Description | The ROSC and XOSC COUNT registers are intended to be used in the configuration of components like PHYs and PLLs where microsecond scale delays are required and NOP loops are inadequate because the clk_sys frequency is variable. However due to a synchronisation issue the ROSC:COUNT and XOSC:COUNT registers are unreliable.
Workaround Do not use ROSC:COUNT or XOSC:COUNT
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Not fixed, do not use. These registers are not used by the C SDK.

### RP2040-E10

   |   
----------|----------
Reference | RP2040-E10
Summary | BADWRITE field in ROSC STATUS register is unreliable
Description | The BADWRITE field in the ROSC STATUS register was intended to report when invalid values had been written to other ROSC registers. However due to internal bugs the ROSC:STATUS.BADWRITE field is unreliable.
Workaround | Do not use ROSC:STATUS.BADWRITE field
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Not fixed, do not use. This field is not used by the C SDK.

## DMA

### RP2040-E12

   |   
----------|----------
Reference | RP2040-E12
Summary | Reading DMA WRITE_ADDR and READ_ADDR registers when an address-wrapping or non-incrementing transfer sequence is in progress gives wrong values
Description | The DMA’s internal WRITE_ADDR and READ_ADDR registers are incremented every time the DMA issues a new address to its bus pipeline. If the processor reads these registers whilst a sequence of transfers is in progress, the value reported by the DMA is adjusted downward by the number of in-flight transfers (i.e. issued to the bus pipeline and not yet completed) times the individual transfer size in bytes. <br> <br> This logic was added to ensure that reading READ_ADDR and WRITE_ADDR reflects addresses where the read/write has completed , not merely where the address has been issued. This logic does not take into account that READ_ADDR and WRITE_ADDR do not increment linearly for some transfer modes, specifically, when CTRL.INCR_WRITE == 0, CTRL.INCR_READ == 0 or CTRL.RING_SIZE != 0.
Workaround | Instead of checking READ_ADDR or WRITE_ADDR to monitor the progress of a transfer sequence, check TRANS_COUNT. <br> <br> TRANS_COUNT has similar in-flight adjustment logic, but is not affected by this erratum because it always decrements linearly. The correct values of READ_ADDR and WRITE_ADDR can be calculated based on their initial values and TRANS_COUNT.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Documentation

### RP2040-E13

   |   
----------|----------
Reference | RP2040-E13
Summary | After aborting a channel, the ABORT status clears prematurely, and an interrupt may be asserted Description The DMA ABORT register is used to cancel an ongoing sequence of transfers, for example when a channel is stuck on an inactive peripheral DREQ. If, at the point the abort is triggered, the channel currently has any transfers in flight (i.e. the read cycle of the transfer has taken place, but the write cycle has not), the ABORT bit does not wait for these in-flight transfers to complete before clearing. <br> <br> When the in-flight transfers complete, because the ABORT bit was prematurely cleared, the DMA treats this as a normal completion. This sets the channel’s interrupt status flag, assuming CTRL.IRQ_QUIET has not been set.
Workaround | Before aborting a channel, clear its interrupt enable. After aborting a channel, poll the CTRL.BUSY bit to wait for completion (not the ABORT bit), clear the spurious IRQ, and restore the interrupt enable.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Software

## GPIO / ADC

### RP2040-E6

   |   
----------|----------
Reference | RP2040-E6
Summary | GPIO digital inputs not disabled for ADC pins by default
Description | GPIO26-29 are shared with ADC inputs AIN0-3. The GPIO digital input is enabled after RUN is released. If the pins are connected to an analogue signal to measure, there could be unexpected signal levels on these pads. This is unlikely to cause a problem as the digital inputs have hysteresis enabled by default.
Workaround | If analogue inputs are used, the digital input should be disabled as early as possible after startup. This is done in the RP2040B2 bootrom and early on in SDK platform setup code on RP2040B0 and RP2040B1. If user wishes to use digital inputs, they must be enabled. Affects | RP2040B0, RP2040B1
Fixed by | RP2040B2 bootrom. Fixed on RP2040B0 and RP2040B1 in SDK. Custom user code should disable these inputs early on.

### RP2040-E11

   |   
----------|----------
Reference | RP2040-E11
Summary | DNL error peaks in ADC
Description | The RP2040 ADC has a DNL that is mostly flat, and below 1 LSB. However at four values $2014 512, 1,536, 2,560, and 3,584 $2014 the ADC’s DNL error peaks above this value. The ENOB for the ADC has been reduced from 9-bits (simulated) to 8.7-bits (measured), see Section 4.9.3. The DNL errors will somewhat limit the performance of the ADC dependent on use case.
Workaround | None
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Not fixed.

## USB

### RP2040-E2

   |   
----------|----------
Reference | RP2040-E2
Summary | USB device endpoint abort is not cleared.
Description | The USB device controller (Section 4.1) has the ability to abort any pending transactions on an endpoint by setting that endpoint’s bit in the **EP_ABORT** register. Due to a logic error, the USB device controller will reply with NAKs forever on all endpoints if a transaction is initiated for any endpoint with the **EP_ABORT** bit set.
Workaround | Do not use the **EP_ABORT** bits.
Affects | RP2040B0, RP2040B1
Fixed by | RP2040B2

### RP2040-E3

   |   
----------|----------
Reference | RP2040-E3
Summary | USB host: interrupt endpoint buffer done flag can be set with incorrect buffer select.
Description | The USB host has two types of transactions: normal software initiated transfer, and interrupt transfers, where the host polls an interrupt endpoint after a specific amount of time. For example, polling a mouse every 1ms to check for movement. Interrupt transfer are single buffered, but the controller doesn’t reset the buffer selector to zero. This means that if a software initiated transfer happened then the interrupt transfer can potentially raise the buffer done flag with BUF1 selected instead of BUF0. The fix is to ignore the **BUFF_CPU_SHOULD_HANDLE** register for interrupt endpoints.
Workaround | 
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Software

### RP2040-E4

   |   
----------|----------
Reference | RP2040-E4
Summary | USB host writes to upper half of buffer status in single buffered mode.
Description | The USB host maintains a buffer selector which switches between BUF0 and BUF1. This should only be toggled in double buffered mode but is toggled in single buffered mode too. For a transaction lasting multiple packets (i.e. length more than 8 bytes in low speed mode, and length more than 64 bytes in full speed mode), the buffer status can be written back to the BUF1 half of the status register when the buffer select is incorrectly set to BUF1. Note this does not affect reading new buffer information from the buffer control register, as the controller ignores the buffer selector in single buffered mode when reading the buffer control register.
Workaround | Shift endpoint control register to the right by 16 bits if the buffer selector is BUF1. You can use **BUFF_CPU_SHOULD_HANDLE** find the value of the buffer selector when the buffer was marked as done.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Software

### RP2040-E5

   |   
----------|----------
Reference | RP2040-E5
Summary | USB device fails to exit RESET state on busy USB bus.
Description | The USB bus RESET state is triggered by the host sending SE0 for 10ms to the device. The USB device controller requires 800μs of idle (J-state) after a bus reset before moving to the CONNECTED state. Without this idle time, the USB device does not connect and will not receive any packets from the host, and so does not enumerate. <br> <br> A device reset happens just after the device is plugged in. Although a host will wait before talking to a newly-reset device, other devices attached to the same USB hub may also be communicating with the host. <br> <br> USB 2.0 and USB 3.0 hubs have one or more transaction translators, which facilitate low speed and full speed transactions on a higher speed bus. It depends on the hub design, but a transaction translator is usually shared between a few ports. <br> <br> As the RP2040 USB device is full speed, its traffic when connected to a hub will come via a transaction translator. This means that if you have another device plugged in next to an RP2040, the RP2040 is likely to see some messages from the host addressed to the other device. If the device is not very active, for example, a mouse that is polled every 8ms, this is not a problem. However some devices, such as a USB serial port, are polled every 30-50μs. In this case the bus is very active, and will cause the RP2040 to never exit RESET state and not connect. <br> <br> There is a hardware fix in RP2040B2 which avoids the need for 800μs of IDLE time after RESET state. <br> <br> There is a software workaround for this issue (see workaround section). A user can also work around this by closing the USB serial port or any other offending devices while connecting their RP2040 and then re- opening their USB serial port. <br> <br> On a larger hub, the problem may be fixed by moving the RP2040 far away (onto a different transaction translator) from the offending device. For example, connecting the RP2040 to port 1 of a 7 port hub, and connecting the USB serial console to port 7, may solve the issue. Connecting the RP2040 to a separate USB hub to any busy devices will also fix the problem.
Workaround | Use software to force USB device controller to see idle USB bus for 800μs to move the device from the RESET state to the CONNECTED state. This fix uses internal debug logic that is connected to GPIO15 for a short amount of time (~800μs). This forces the controller to see DP as a logical 1 (and DM as logical 0) to make the USB Device controller believe there is a J-state on the USB bus. GPIO15 does not need to be tied in any particular way for this fix to work. Instead, we can force the input path in software using the Section 2.19 input override feature. See [https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_fix/rp2040_usb_device_enumeration/rp2040_usb_device_enumeration.c](https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_fix/rp2040_usb_device_enumeration/rp2040_usb_device_enumeration.c) . <br> <br> **NOTE** The workaround takes control of GPIO 15 during a device reset, so you need to be sure that you are not using GPIO 15 for anything else during a device reset before using the workaround. A device reset happens after the first connection, but may also happen at other times under the host’s control. <br> <br> Using the workaround with TinyUSB and the SDK is easy, as the above source file is included by the library pico_fix_rp2040_usb_device_enumeration (which is automatically added as a dependency of TinyUSB in device mode). The fix itself is still off by default though, since the fix’s use of GPIO 15 may conflict with the application’s own use of GPIO 15. You can enable it by setting either PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1 as part of your compiler definitions in your CMakeLists.txt, or TUD_OPT_RP2040_USB_DEVICE_ENUMERATION_FIX=1 in your tusb_config.h. <br> <br> It is safe (and inexpensive) to enable the software workaround even when using versions of RP2040 which include the fix in hardware.
Affects | RP2040B0, RP2040B1
Fixed by | RP2040B2. Software workaround on RP2040B0, RP2040B1. The workaround isn’t present in the USB mass storage code in the bootrom. The software workaround requires use of GPIO15 during USB bus reset.

### RP2040-E15

   |   
----------|----------
Reference | RP2040-E15
Summary | USB Device controller will hang if certain bus errors occur during an IN transfer.
Description | The USB Device controller enters an unrecoverable state if the following critical sequence of events occurs: <br> RP2040 is connected to a VL805 xHCI controller and is operating in full-speed mode <br> The integrated hub detects an impending line collision between downstream port Transaction Translator traffic and broadcast upstream traffic (Start-of-Frame token) <br> The integrated hub forces a bitstuffing error during the PID or CRC portions of the downstream in- progress packet or token. <br> This sequence is known to occur with the downstream-facing ports on a Raspberry Pi 4 or a Raspberry Pi 400 and Bulk IN endpoints with data buffer sizes of more than 50 bytes. In this case, the integrated USB2.0 hub incorrectly determines the remaining full-speed frame time in anticipation of a SOF packet from the host, and erroneously transmits an IN token which results in the later ACK reply being corrupted and replaced by the propagated SOF packet. This type of data corruption is not properly handled by the device state machine, and the device controller must be reset. <br> <br> This sequence has not been seen to occur on commodity USB2.0 hubs, nor on Root Ports that are not provided by a VL805 xHCI controller.
Workarounds | 1) VL805 firmware version 0138c1 <br> <br> An updated firmware has been pushed to the DEFAULT channel in the raspberrypi-bootloader Apt package on Pi 4 products. This corrects the erroneous hub time calculation. This firmware update is not automatically applied, users must run sudo rpi-eeprom-update -a on the Pi 4 and follow on-screen instructions. <br> <br> 2) Linux Kernel xHCI driver patch <br> <br> A kernel update is available for the Raspberry Pi 4-series products that, for VL805 firmware versions earlier than 0138c1, avoids enqueueing single Transfer Descriptors to the controller for affected endpoints during the last microframe of a full-speed frame. This update is available in the raspberrypi- kernel Apt package. <br> <br> 2) SDK v1.5.0 / TinyUSB 0.15.0 <br> <br> TinyUSB starting at version 0.15.0 adds a workaround for this erratum, and this version is picked up in the v1.5.0 release of the SDK. The dcd_rp2040 driver will avoid enabling bulk IN buffers during the last 200 μs of a full-speed frame. This reduces available Bulk IN bandwidth by approximately 20%, and selectively enables the Start-of-Frame interrupt. <br> <br> The TinyUSB workaround is not necessary for implementations that will never be connected to a vulnerable VL805 port, for example in a circuit design where RP2040 is directly connected to an on-board hub. The workaround can be disabled by defining TUD_OPT_RP2040_USB_DEVICE_UFRAME_FIX=0 in your tusb_config.h.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Documentation, Software

## Watchdog

### RP2040-E1

   |   
----------|----------
Reference | RP2040-E1
Summary | Watchdog count is decremented twice per tick.
Description | The watchdog (Section 4.7) has a 24-bit counter, that decrements every tick, starting from a user defined value set in LOAD register. There is a logic error which means the counter is decremented twice per tick, instead of once per tick. In a recommended setup where the tick occurs at 1μs intervals, this halves the maximum time between resetting the watchdog counter from ~16.7 seconds to ~8.3 seconds.
Workaround | Use double the desired value in LOAD.
Affects | RP2040B0, RP2040B1, RP2040B2
Fixed by | Documentation, Software

## XIP Flash

### RP2040-E8

   |   
----------|----------
Reference | RP2040-E8
Summary | Race condition when aborting an XIP DMA stream and immediately starting a new stream
Description | The XIP DMA streaming hardware allows a linear sequences of flash reads to proceed in the background, and be read by the DMA, without subjecting the DMA to the bus stalls caused by a normal XIP-window access. A stream is begun by writing to the STREAM_ADDR register, followed by STREAM_CTR, and can be aborted midway by writing 0 to STREAM_CTR.<br><br> When a stream is aborted in this way, there is sufficient time for software to load a new address and begin a new stream whilst the final SPI/QSPI access of the aborted stream is still in progress. This causes the newly-loaded stream address to be incremented once before the first data transfer of the new stream sequence, so the entire stream takes place at a 4-byte offset.
Workaround | After clearing STREAM_CTR, immediately perform one dummy read from the uncached XIP window, e.g. (void)*(io_ro_32*)XIP_NOCACHE_NOALLOC_BASE;. If an XIP stream transfer is still in progress, this dummy read will stall until that transfer completes. It is then safe to begin a new stream by writing to STREAM_ADDR followed by STREAM_CTR.
Affects  | RP2040B0, RP2040B1, RP2040B2
Fixed by  | Documentation, Software



